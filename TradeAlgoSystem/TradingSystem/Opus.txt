// Core Domain Models
namespace TradingSystem.Core.Models
{
    public class TickBar
    {
        public int TickSize { get; set; }
        public int TickCount { get; set; }
        public decimal Volume { get; set; }
        public decimal AskVolume { get; set; }
        public decimal BidVolume { get; set; }
        public decimal OpenPrice { get; set; }
        public decimal HighPrice { get; set; }
        public decimal LowPrice { get; set; }
        public decimal ClosePrice { get; set; }
        public DateTime FormationStartTime { get; set; }
        public TimeSpan FormationTime => DateTime.UtcNow - FormationStartTime;
        public decimal OpenPosAskChange { get; set; }
        public decimal OpenPosBidChange { get; set; }
        public decimal PriceImpact { get; set; }
        public decimal Delta => BidVolume - AskVolume;
        public decimal DeltaPercentage => Volume > 0 ? Delta / Volume : 0;
        public decimal PriceRange => HighPrice - LowPrice;
    }

    public class Trade
    {
        public string Id { get; set; }
        public decimal Price { get; set; }
        public decimal Volume { get; set; }
        public TradeSide Side { get; set; }
        public DateTime Timestamp { get; set; }
        public string Exchange { get; set; }
    }

    public enum TradeSide
    {
        Buy,
        Sell
    }

    public class OrderBookSnapshot
    {
        public List<OrderBookLevel> Bids { get; set; }
        public List<OrderBookLevel> Asks { get; set; }
        public DateTime Timestamp { get; set; }
    }

    public class OrderBookLevel
    {
        public decimal Price { get; set; }
        public decimal Volume { get; set; }
        public int OrderCount { get; set; }
    }

    public class MarketMetrics
    {
        public decimal OpenInterest { get; set; }
        public decimal OpenInterestChange { get; set; }
        public decimal FundingRate { get; set; }
        public decimal ATR { get; set; }
        public decimal VWAP { get; set; }
        public DateTime Timestamp { get; set; }
    }

    public class ImbalanceSignal
    {
        public SignalType Type { get; set; }
        public SignalStrength Strength { get; set; }
        public string Description { get; set; }
        public Dictionary<string, decimal> Metrics { get; set; }
        public DateTime Timestamp { get; set; }
        public decimal ConfidenceLevel { get; set; }
    }

    public enum SignalType
    {
        BearishBreakthrough,
        BullishBreakthrough,
        ExtremeImbalance,
        FastBreakthrough,
        WhaleActivity,
        Accumulation,
        Distribution,
        TrueBreakout,
        FalseBreakout
    }

    public enum SignalStrength
    {
        Critical,
        Strong,
        Moderate,
        Weak
    }

    public class AccumulationZone
    {
        public decimal PriceLevel { get; set; }
        public decimal VolumeAccumulated { get; set; }
        public TimeSpan Duration { get; set; }
        public decimal OpenPosImbalance { get; set; }
        public ZoneType Type { get; set; }
        public DateTime StartTime { get; set; }
        public DateTime? EndTime { get; set; }
        public int TouchCount { get; set; }
        public decimal StrengthScore { get; set; }
    }

    public enum ZoneType
    {
        Support,
        Resistance,
        Accumulation,
        Distribution
    }
}

// Exchange Interfaces
namespace TradingSystem.Exchange.Interfaces
{
    public interface IExchangeClient
    {
        Task<bool> ConnectAsync();
        Task DisconnectAsync();
        Task SubscribeToTradesAsync(string symbol);
        Task SubscribeToOrderBookAsync(string symbol);
        Task SubscribeToOpenInterestAsync(string symbol);
        Task<OrderBookSnapshot> GetOrderBookAsync(string symbol, int depth = 100);
        Task<decimal> GetOpenInterestAsync(string symbol);
        Task<List<Trade>> GetRecentTradesAsync(string symbol, int limit = 1000);
        event EventHandler<Trade> OnTradeReceived;
        event EventHandler<OrderBookSnapshot> OnOrderBookUpdate;
        event EventHandler<decimal> OnOpenInterestUpdate;
        string ExchangeName { get; }
    }

    public interface IDataAggregator
    {
        void ProcessTrade(Trade trade);
        void UpdateOrderBook(OrderBookSnapshot snapshot);
        void UpdateOpenInterest(decimal openInterest, string exchange);
        MarketMetrics GetCurrentMetrics();
        List<TickBar> GetTickBars(int tickSize, int count);
    }
}

// Strategy Detection
namespace TradingSystem.Strategy
{
    public interface IImbalanceDetector
    {
        List<ImbalanceSignal> DetectImbalances(List<TickBar> bars);
        bool CheckBearishBreakthrough(TickBar bar);
        bool CheckBullishBreakthrough(TickBar bar);
        bool CheckExtremeImbalance(TickBar bar);
        bool CheckWhaleActivity(TickBar bar);
    }

    public class ImbalanceDetector : IImbalanceDetector
    {
        private readonly ImbalanceConfig _config;
        private readonly IMarketAnalyzer _analyzer;

        public ImbalanceDetector(ImbalanceConfig config, IMarketAnalyzer analyzer)
        {
            _config = config;
            _analyzer = analyzer;
        }

        public List<ImbalanceSignal> DetectImbalances(List<TickBar> bars)
        {
            var signals = new List<ImbalanceSignal>();

            foreach (var bar in bars)
            {
                // Bearish Breakthrough Detection
                if (CheckBearishBreakthrough(bar))
                {
                    signals.Add(CreateSignal(SignalType.BearishBreakthrough, bar));
                }

                // Bullish Breakthrough Detection
                if (CheckBullishBreakthrough(bar))
                {
                    signals.Add(CreateSignal(SignalType.BullishBreakthrough, bar));
                }

                // Extreme Imbalance Detection
                if (CheckExtremeImbalance(bar))
                {
                    signals.Add(CreateSignal(SignalType.ExtremeImbalance, bar));
                }

                // Whale Activity Detection
                if (CheckWhaleActivity(bar))
                {
                    signals.Add(CreateSignal(SignalType.WhaleActivity, bar));
                }
            }

            return signals;
        }

        public bool CheckBearishBreakthrough(TickBar bar)
        {
            return bar.OpenPosAskChange > bar.OpenPosBidChange * _config.BearishMultiplier
                && bar.DeltaPercentage < -_config.DeltaThreshold
                && bar.AskVolume > bar.BidVolume * _config.VolumeRatio
                && bar.TickCount < _config.FastTickThreshold
                && bar.OpenPosAskChange > _config.MinOpenPosChange
                && bar.Volume > _analyzer.GetAverageVolume(10) * _config.VolumeMultiplier
                && bar.PriceRange > _config.MinPriceMovement;
        }

        public bool CheckBullishBreakthrough(TickBar bar)
        {
            return bar.OpenPosBidChange > bar.OpenPosAskChange * _config.BullishMultiplier
                && bar.DeltaPercentage > _config.DeltaThreshold
                && bar.BidVolume > bar.AskVolume * _config.VolumeRatio
                && bar.TickCount < _config.FastTickThreshold
                && bar.OpenPosBidChange > _config.MinOpenPosChange
                && bar.Volume > _analyzer.GetAverageVolume(10) * _config.VolumeMultiplier
                && bar.PriceRange > _config.MinPriceMovement;
        }

        public bool CheckExtremeImbalance(TickBar bar)
        {
            var imbalance = Math.Abs(bar.OpenPosAskChange - bar.OpenPosBidChange);
            return imbalance > _config.ExtremeImbalanceThreshold
                || Math.Abs(bar.DeltaPercentage) > _config.ExtremeDeltaThreshold
                || (bar.AskVolume / bar.BidVolume > _config.ExtremeRatioThreshold ||
                    bar.BidVolume / bar.AskVolume > _config.ExtremeRatioThreshold);
        }

        public bool CheckWhaleActivity(TickBar bar)
        {
            return bar.TickCount <= _config.WhaleTickThreshold
                && bar.Volume > _config.WhaleVolumeThreshold
                && Math.Abs(bar.OpenPosAskChange - bar.OpenPosBidChange) > _config.WhaleImbalanceThreshold
                && bar.PriceImpact > _config.WhalePriceImpact
                && bar.FormationTime.TotalSeconds < _config.WhaleTimeThreshold;
        }

        private ImbalanceSignal CreateSignal(SignalType type, TickBar bar)
        {
            return new ImbalanceSignal
            {
                Type = type,
                Strength = CalculateStrength(type, bar),
                Description = GenerateDescription(type, bar),
                Metrics = ExtractMetrics(bar),
                Timestamp = DateTime.UtcNow,
                ConfidenceLevel = CalculateConfidence(type, bar)
            };
        }

        private SignalStrength CalculateStrength(SignalType type, TickBar bar)
        {
            // Implementation of strength calculation logic
            var score = 0m;
            
            // Add scoring logic based on various factors
            if (bar.Volume > _analyzer.GetAverageVolume(20) * 3) score += 30;
            if (Math.Abs(bar.DeltaPercentage) > 0.75m) score += 25;
            if (bar.FormationTime.TotalSeconds < 10) score += 20;
            
            if (score > 70) return SignalStrength.Critical;
            if (score > 50) return SignalStrength.Strong;
            if (score > 30) return SignalStrength.Moderate;
            return SignalStrength.Weak;
        }

        private string GenerateDescription(SignalType type, TickBar bar)
        {
            return $"{type}: Vol={bar.Volume:F2}, Delta={bar.DeltaPercentage:P}, OI_Imb={bar.OpenPosAskChange - bar.OpenPosBidChange:F2}";
        }

        private Dictionary<string, decimal> ExtractMetrics(TickBar bar)
        {
            return new Dictionary<string, decimal>
            {
                ["Volume"] = bar.Volume,
                ["Delta"] = bar.Delta,
                ["DeltaPercentage"] = bar.DeltaPercentage,
                ["OpenPosImbalance"] = bar.OpenPosAskChange - bar.OpenPosBidChange,
                ["PriceImpact"] = bar.PriceImpact,
                ["FormationSeconds"] = (decimal)bar.FormationTime.TotalSeconds
            };
        }

        private decimal CalculateConfidence(SignalType type, TickBar bar)
        {
            // Calculate confidence level based on multiple factors
            var confidence = 0.5m;
            
            if (bar.Volume > _analyzer.GetAverageVolume(20) * 2) confidence += 0.2m;
            if (Math.Abs(bar.DeltaPercentage) > 0.7m) confidence += 0.15m;
            if (_analyzer.GetATR() > 0 && bar.PriceRange > _analyzer.GetATR() * 0.8m) confidence += 0.15m;
            
            return Math.Min(confidence, 1.0m);
        }
    }

    public class ImbalanceConfig
    {
        public decimal BearishMultiplier { get; set; } = 2.5m;
        public decimal BullishMultiplier { get; set; } = 2.5m;
        public decimal DeltaThreshold { get; set; } = 0.6m;
        public decimal VolumeRatio { get; set; } = 1.8m;
        public int FastTickThreshold { get; set; } = 15;
        public decimal MinOpenPosChange { get; set; } = 50;
        public decimal VolumeMultiplier { get; set; } = 2;
        public decimal MinPriceMovement { get; set; } = 0.5m;
        public decimal ExtremeImbalanceThreshold { get; set; } = 100;
        public decimal ExtremeDeltaThreshold { get; set; } = 0.75m;
        public decimal ExtremeRatioThreshold { get; set; } = 4;
        public int WhaleTickThreshold { get; set; } = 8;
        public decimal WhaleVolumeThreshold { get; set; } = 100;
        public decimal WhaleImbalanceThreshold { get; set; } = 75;
        public decimal WhalePriceImpact { get; set; } = 0.3m;
        public int WhaleTimeThreshold { get; set; } = 30;
    }

    public interface IMarketAnalyzer
    {
        decimal GetAverageVolume(int periods);
        decimal GetATR();
        List<AccumulationZone> DetectAccumulationZones(List<TickBar> bars);
        bool IsBreakout(TickBar currentBar, AccumulationZone zone);
        BreakoutInfo AnalyzeBreakout(List<TickBar> bars, AccumulationZone zone);
    }

    public class BreakoutInfo
    {
        public BreakoutType Type { get; set; }
        public BreakoutGrade Grade { get; set; }
        public decimal Strength { get; set; }
        public bool IsConfirmed { get; set; }
        public decimal VolumeExpansion { get; set; }
        public decimal PriceExtension { get; set; }
    }

    public enum BreakoutType
    {
        Bullish,
        Bearish,
        False
    }

    public enum BreakoutGrade
    {
        Explosive,  // Grade A
        Strong,     // Grade B
        Moderate    // Grade C
    }
}

// Tick Bar Builder
namespace TradingSystem.Processing
{
    public class TickBarBuilder
    {
        private readonly Dictionary<int, TickBar> _currentBars = new();
        private readonly Dictionary<int, List<TickBar>> _completedBars = new();
        private readonly int[] _tickSizes = { 500, 1000, 5000, 15000 };
        private decimal _lastPrice;
        private decimal _currentOpenInterest;

        public TickBarBuilder()
        {
            foreach (var size in _tickSizes)
            {
                _currentBars[size] = new TickBar 
                { 
                    TickSize = size,
                    FormationStartTime = DateTime.UtcNow 
                };
                _completedBars[size] = new List<TickBar>();
            }
        }

        public void ProcessTrade(Trade trade)
        {
            foreach (var size in _tickSizes)
            {
                UpdateTickBar(_currentBars[size], trade);
                
                if (_currentBars[size].TickCount >= size)
                {
                    CompleteBar(size);
                }
            }
            
            _lastPrice = trade.Price;
        }

        private void UpdateTickBar(TickBar bar, Trade trade)
        {
            bar.TickCount++;
            bar.Volume += trade.Volume;
            
            if (trade.Side == TradeSide.Sell)
                bar.AskVolume += trade.Volume;
            else
                bar.BidVolume += trade.Volume;
            
            if (bar.TickCount == 1)
            {
                bar.OpenPrice = trade.Price;
                bar.HighPrice = trade.Price;
                bar.LowPrice = trade.Price;
            }
            else
            {
                bar.HighPrice = Math.Max(bar.HighPrice, trade.Price);
                bar.LowPrice = Math.Min(bar.LowPrice, trade.Price);
            }
            
            bar.ClosePrice = trade.Price;
            
            // Calculate price impact
            if (_lastPrice > 0 && bar.TickCount == 1)
            {
                bar.PriceImpact = Math.Abs(trade.Price - _lastPrice);
            }
        }

        private void CompleteBar(int size)
        {
            var completedBar = _currentBars[size];
            CalculateFinalMetrics(completedBar);
            _completedBars[size].Add(completedBar);
            
            // Start new bar
            _currentBars[size] = new TickBar
            {
                TickSize = size,
                FormationStartTime = DateTime.UtcNow
            };
            
            // Trigger event for completed bar
            OnBarCompleted?.Invoke(this, completedBar);
        }

        private void CalculateFinalMetrics(TickBar bar)
        {
            // Estimate OpenPos changes based on volume distribution
            var totalVolume = bar.AskVolume + bar.BidVolume;
            if (totalVolume > 0)
            {
                if (bar.AskVolume > bar.BidVolume)
                {
                    bar.OpenPosAskChange = (_currentOpenInterest * (bar.AskVolume / totalVolume));
                }
                else
                {
                    bar.OpenPosBidChange = (_currentOpenInterest * (bar.BidVolume / totalVolume));
                }
            }
        }

        public void UpdateOpenInterest(decimal openInterest)
        {
            var change = openInterest - _currentOpenInterest;
            _currentOpenInterest = openInterest;
            
            // Distribute OI change to current bars based on their volume
            foreach (var bar in _currentBars.Values)
            {
                if (bar.AskVolume > bar.BidVolume)
                {
                    bar.OpenPosAskChange += change * (bar.AskVolume / bar.Volume);
                }
                else
                {
                    bar.OpenPosBidChange += change * (bar.BidVolume / bar.Volume);
                }
            }
        }

        public List<TickBar> GetCompletedBars(int tickSize, int count)
        {
            if (!_completedBars.ContainsKey(tickSize))
                return new List<TickBar>();
                
            var bars = _completedBars[tickSize];
            return bars.Skip(Math.Max(0, bars.Count - count)).ToList();
        }

        public event EventHandler<TickBar> OnBarCompleted;
    }

    public class MarketDataAggregator : IDataAggregator
    {
        private readonly TickBarBuilder _barBuilder;
        private readonly Queue<Trade> _recentTrades = new();
        private readonly Dictionary<string, decimal> _openInterestByExchange = new();
        private OrderBookSnapshot _latestOrderBook;
        private MarketMetrics _currentMetrics = new();
        private readonly int _maxTradeHistory = 10000;

        public MarketDataAggregator(TickBarBuilder barBuilder)
        {
            _barBuilder = barBuilder;
        }

        public void ProcessTrade(Trade trade)
        {
            _recentTrades.Enqueue(trade);
            if (_recentTrades.Count > _maxTradeHistory)
                _recentTrades.Dequeue();
                
            _barBuilder.ProcessTrade(trade);
            UpdateMetrics();
        }

        public void UpdateOrderBook(OrderBookSnapshot snapshot)
        {
            _latestOrderBook = snapshot;
            UpdateMetrics();
        }

        public void UpdateOpenInterest(decimal openInterest, string exchange)
        {
            _openInterestByExchange[exchange] = openInterest;
            _currentMetrics.OpenInterest = _openInterestByExchange.Values.Average();
            _barBuilder.UpdateOpenInterest(_currentMetrics.OpenInterest);
        }

        public MarketMetrics GetCurrentMetrics()
        {
            return _currentMetrics;
        }

        public List<TickBar> GetTickBars(int tickSize, int count)
        {
            return _barBuilder.GetCompletedBars(tickSize, count);
        }

        private void UpdateMetrics()
        {
            // Update VWAP
            if (_recentTrades.Any())
            {
                var vwapSum = _recentTrades.Sum(t => t.Price * t.Volume);
                var volumeSum = _recentTrades.Sum(t => t.Volume);
                _currentMetrics.VWAP = volumeSum > 0 ? vwapSum / volumeSum : 0;
            }
            
            // Update ATR (simplified)
            var bars = _barBuilder.GetCompletedBars(1000, 14);
            if (bars.Count >= 14)
            {
                _currentMetrics.ATR = bars.Average(b => b.PriceRange);
            }
            
            _currentMetrics.Timestamp = DateTime.UtcNow;
        }
    }
}

// Main Orchestrator
namespace TradingSystem.Core
{
    public class TradingSystemOrchestrator
    {
        private readonly List<IExchangeClient> _exchanges;
        private readonly IDataAggregator _dataAggregator;
        private readonly IImbalanceDetector _imbalanceDetector;
        private readonly IMarketAnalyzer _marketAnalyzer;
        private readonly INotificationService _notificationService;
        private readonly Timer _analysisTimer;
        private readonly SemaphoreSlim _analysisSemaphore = new(1, 1);

        public TradingSystemOrchestrator(
            List<IExchangeClient> exchanges,
            IDataAggregator dataAggregator,
            IImbalanceDetector imbalanceDetector,
            IMarketAnalyzer marketAnalyzer,
            INotificationService notificationService)
        {
            _exchanges = exchanges;
            _dataAggregator = dataAggregator;
            _imbalanceDetector = imbalanceDetector;
            _marketAnalyzer = marketAnalyzer;
            _notificationService = notificationService;
            
            // Run analysis every 100ms
            _analysisTimer = new Timer(async _ => await RunAnalysisAsync(), null, 
                TimeSpan.FromMilliseconds(100), TimeSpan.FromMilliseconds(100));
        }

        public async Task StartAsync()
        {
            // Connect to all exchanges
            var connectTasks = _exchanges.Select(e => ConnectExchange(e));
            await Task.WhenAll(connectTasks);
            
            Console.WriteLine($"Connected to {_exchanges.Count} exchanges");
        }

        private async Task ConnectExchange(IExchangeClient exchange)
        {
            try
            {
                await exchange.ConnectAsync();
                
                // Subscribe to data streams
                await exchange.SubscribeToTradesAsync("ETHUSDT");
                await exchange.SubscribeToOrderBookAsync("ETHUSDT");
                await exchange.SubscribeToOpenInterestAsync("ETHUSDT");
                
                // Hook up event handlers
                exchange.OnTradeReceived += (s, trade) => _dataAggregator.ProcessTrade(trade);
                exchange.OnOrderBookUpdate += (s, book) => _dataAggregator.UpdateOrderBook(book);
                exchange.OnOpenInterestUpdate += (s, oi) => _dataAggregator.UpdateOpenInterest(oi, exchange.ExchangeName);
                
                Console.WriteLine($"Connected to {exchange.ExchangeName}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to connect to {exchange.ExchangeName}: {ex.Message}");
            }
        }

        private async Task RunAnalysisAsync()
        {
            if (!await _analysisSemaphore.WaitAsync(0))
                return; // Skip if previous analysis still running
                
            try
            {
                // Get tick bars for different sizes
                var tickSizes = new[] { 500, 1000, 5000, 15000 };
                var allSignals = new List<ImbalanceSignal>();
                
                foreach (var size in tickSizes)
                {
                    var bars = _dataAggregator.GetTickBars(size, 50);
                    if (bars.Count == 0) continue;
                    
                    // Detect imbalances
                    var signals = _imbalanceDetector.DetectImbalances(bars);
                    allSignals.AddRange(signals);
                    
                    // Detect accumulation zones
                    var zones = _marketAnalyzer.DetectAccumulationZones(bars);
                    
                    // Check for breakouts
                    foreach (var zone in zones)
                    {
                        if (_marketAnalyzer.IsBreakout(bars.LastOrDefault(), zone))
                        {
                            var breakoutInfo = _marketAnalyzer.AnalyzeBreakout(bars, zone);
                            allSignals.Add(CreateBreakoutSignal(breakoutInfo, zone));
                        }
                    }
                }
                
                // Process signals
                await ProcessSignalsAsync(allSignals);
            }
            finally
            {
                _analysisSemaphore.Release();
            }
        }

        private async Task ProcessSignalsAsync(List<ImbalanceSignal> signals)
        {
            // Group by strength
            var criticalSignals = signals.Where(s => s.Strength == SignalStrength.Critical);
            var strongSignals = signals.Where(s => s.Strength == SignalStrength.Strong);
            
            // Send notifications for critical signals
            foreach (var signal in criticalSignals)
            {
                await _notificationService.SendAlertAsync(signal);
            }
            
            // Queue strong signals for validation
            foreach (var signal in strongSignals)
            {
                await _notificationService.QueueForValidationAsync(signal);
            }
            
            // Log moderate signals
            var moderateSignals = signals.Where(s => s.Strength == SignalStrength.Moderate);
            foreach (var signal in moderateSignals)
            {
                Console.WriteLine($"[{signal.Timestamp:HH:mm:ss}] {signal.Type}: {signal.Description}");
            }
        }

        private ImbalanceSignal CreateBreakoutSignal(BreakoutInfo breakout, AccumulationZone zone)
        {
            var signalType = breakout.Type == BreakoutType.Bullish 
                ? SignalType.BullishBreakthrough 
                : SignalType.BearishBreakthrough;
                
            if (breakout.Type == BreakoutType.False)
                signalType = SignalType.FalseBreakout;
                
            var strength = breakout.Grade switch
            {
                BreakoutGrade.Explosive => SignalStrength.Critical,
                BreakoutGrade.Strong => SignalStrength.Strong,
                _ => SignalStrength.Moderate
            };
            
            return new ImbalanceSignal
            {
                Type = signalType,
                Strength = strength,
                Description = $"Breakout from {zone.Type} at {zone.PriceLevel:F2}",
                Metrics = new Dictionary<string, decimal>
                {
                    ["ZoneStrength"] = zone.StrengthScore,
                    ["VolumeExpansion"] = breakout.VolumeExpansion,
                    ["PriceExtension"] = breakout.PriceExtension
                },
                Timestamp = DateTime.UtcNow,
                ConfidenceLevel = breakout.Strength
            };
        }

        public async Task StopAsync()
        {
            _analysisTimer?.Dispose();
            
            var disconnectTasks = _exchanges.Select(e => e.DisconnectAsync());
            await Task.WhenAll(disconnectTasks);
        }
    }

    public interface INotificationService
    {
        Task SendAlertAsync(ImbalanceSignal signal);
        Task QueueForValidationAsync(ImbalanceSignal signal);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Bybit Exchange Implementation
namespace TradingSystem.Exchange.Bybit
{
    using System.Net.WebSockets;
    using System.Text;
    using System.Text.Json;
    using TradingSystem.Core.Models;
    using TradingSystem.Exchange.Interfaces;

    public class BybitClient : IExchangeClient, IDisposable
    {
        private ClientWebSocket _webSocket;
        private CancellationTokenSource _cancellationTokenSource;
        private readonly HttpClient _httpClient;
        private readonly string _wsUrl = "wss://stream.bybit.com/v5/public/linear";
        private readonly string _restUrl = "https://api.bybit.com";
        private Task _receiveTask;
        
        public string ExchangeName => "Bybit";
        
        public event EventHandler<Trade> OnTradeReceived;
        public event EventHandler<OrderBookSnapshot> OnOrderBookUpdate;
        public event EventHandler<decimal> OnOpenInterestUpdate;

        public BybitClient()
        {
            _httpClient = new HttpClient();
            _httpClient.BaseAddress = new Uri(_restUrl);
        }

        public async Task<bool> ConnectAsync()
        {
            try
            {
                _webSocket = new ClientWebSocket();
                _cancellationTokenSource = new CancellationTokenSource();
                
                await _webSocket.ConnectAsync(new Uri(_wsUrl), _cancellationTokenSource.Token);
                
                // Start receive loop
                _receiveTask = Task.Run(() => ReceiveLoop(_cancellationTokenSource.Token));
                
                // Send ping periodically
                _ = Task.Run(() => PingLoop(_cancellationTokenSource.Token));
                
                return _webSocket.State == WebSocketState.Open;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Bybit connection error: {ex.Message}");
                return false;
            }
        }

        public async Task DisconnectAsync()
        {
            if (_webSocket?.State == WebSocketState.Open)
            {
                await _webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, 
                    "Closing connection", CancellationToken.None);
            }
            
            _cancellationTokenSource?.Cancel();
            _webSocket?.Dispose();
            _cancellationTokenSource?.Dispose();
        }

        public async Task SubscribeToTradesAsync(string symbol)
        {
            var subscribeMessage = new
            {
                op = "subscribe",
                args = new[] { $"publicTrade.{symbol}" }
            };
            
            await SendMessageAsync(JsonSerializer.Serialize(subscribeMessage));
        }

        public async Task SubscribeToOrderBookAsync(string symbol)
        {
            var subscribeMessage = new
            {
                op = "subscribe",
                args = new[] { $"orderbook.1.{symbol}" }
            };
            
            await SendMessageAsync(JsonSerializer.Serialize(subscribeMessage));
        }

        public async Task SubscribeToOpenInterestAsync(string symbol)
        {
            // Start periodic REST API calls for Open Interest
            _ = Task.Run(async () =>
            {
                while (!_cancellationTokenSource.Token.IsCancellationRequested)
                {
                    try
                    {
                        var openInterest = await GetOpenInterestAsync(symbol);
                        OnOpenInterestUpdate?.Invoke(this, openInterest);
                        await Task.Delay(5000, _cancellationTokenSource.Token);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"OI update error: {ex.Message}");
                    }
                }
            });
        }

        public async Task<OrderBookSnapshot> GetOrderBookAsync(string symbol, int depth = 100)
        {
            var response = await _httpClient.GetAsync(
                $"/v5/market/orderbook?symbol={symbol}&category=linear&limit={depth}");
            
            if (response.IsSuccessStatusCode)
            {
                var json = await response.Content.ReadAsStringAsync();
                return ParseOrderBook(json);
            }
            
            return null;
        }

        public async Task<decimal> GetOpenInterestAsync(string symbol)
        {
            var response = await _httpClient.GetAsync(
                $"/v5/market/open-interest?symbol={symbol}&category=linear");
            
            if (response.IsSuccessStatusCode)
            {
                var json = await response.Content.ReadAsStringAsync();
                using var doc = JsonDocument.Parse(json);
                
                if (doc.RootElement.TryGetProperty("result", out var result) &&
                    result.TryGetProperty("list", out var list))
                {
                    var firstItem = list.EnumerateArray().FirstOrDefault();
                    if (firstItem.TryGetProperty("openInterest", out var oi))
                    {
                        return oi.GetDecimal();
                    }
                }
            }
            
            return 0;
        }

        public async Task<List<Trade>> GetRecentTradesAsync(string symbol, int limit = 1000)
        {
            var response = await _httpClient.GetAsync(
                $"/v5/market/recent-trade?symbol={symbol}&category=linear&limit={limit}");
            
            if (response.IsSuccessStatusCode)
            {
                var json = await response.Content.ReadAsStringAsync();
                return ParseRecentTrades(json);
            }
            
            return new List<Trade>();
        }

        private async Task ReceiveLoop(CancellationToken cancellationToken)
        {
            var buffer = new ArraySegment<byte>(new byte[4096 * 4]);
            
            while (!cancellationToken.IsCancellationRequested && 
                   _webSocket.State == WebSocketState.Open)
            {
                try
                {
                    var result = await _webSocket.ReceiveAsync(buffer, cancellationToken);
                    
                    if (result.MessageType == WebSocketMessageType.Text)
                    {
                        var message = Encoding.UTF8.GetString(buffer.Array, 0, result.Count);
                        ProcessMessage(message);
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Receive error: {ex.Message}");
                }
            }
        }

        private void ProcessMessage(string message)
        {
            try
            {
                using var doc = JsonDocument.Parse(message);
                
                if (doc.RootElement.TryGetProperty("topic", out var topic))
                {
                    var topicStr = topic.GetString();
                    
                    if (topicStr.StartsWith("publicTrade"))
                    {
                        ProcessTradeMessage(doc.RootElement);
                    }
                    else if (topicStr.StartsWith("orderbook"))
                    {
                        ProcessOrderBookMessage(doc.RootElement);
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Process message error: {ex.Message}");
            }
        }

        private void ProcessTradeMessage(JsonElement root)
        {
            if (root.TryGetProperty("data", out var data))
            {
                foreach (var trade in data.EnumerateArray())
                {
                    var tradeObj = new Trade
                    {
                        Id = trade.GetProperty("i").GetString(),
                        Price = trade.GetProperty("p").GetDecimal(),
                        Volume = trade.GetProperty("v").GetDecimal(),
                        Side = trade.GetProperty("S").GetString() == "Buy" 
                            ? TradeSide.Buy : TradeSide.Sell,
                        Timestamp = DateTimeOffset.FromUnixTimeMilliseconds(
                            trade.GetProperty("T").GetInt64()).UtcDateTime,
                        Exchange = ExchangeName
                    };
                    
                    OnTradeReceived?.Invoke(this, tradeObj);
                }
            }
        }

        private void ProcessOrderBookMessage(JsonElement root)
        {
            if (root.TryGetProperty("data", out var data))
            {
                var snapshot = new OrderBookSnapshot
                {
                    Bids = new List<OrderBookLevel>(),
                    Asks = new List<OrderBookLevel>(),
                    Timestamp = DateTime.UtcNow
                };
                
                if (data.TryGetProperty("b", out var bids))
                {
                    foreach (var bid in bids.EnumerateArray())
                    {
                        snapshot.Bids.Add(new OrderBookLevel
                        {
                            Price = decimal.Parse(bid[0].GetString()),
                            Volume = decimal.Parse(bid[1].GetString())
                        });
                    }
                }
                
                if (data.TryGetProperty("a", out var asks))
                {
                    foreach (var ask in asks.EnumerateArray())
                    {
                        snapshot.Asks.Add(new OrderBookLevel
                        {
                            Price = decimal.Parse(ask[0].GetString()),
                            Volume = decimal.Parse(ask[1].GetString())
                        });
                    }
                }
                
                OnOrderBookUpdate?.Invoke(this, snapshot);
            }
        }

        private OrderBookSnapshot ParseOrderBook(string json)
        {
            using var doc = JsonDocument.Parse(json);
            var snapshot = new OrderBookSnapshot
            {
                Bids = new List<OrderBookLevel>(),
                Asks = new List<OrderBookLevel>(),
                Timestamp = DateTime.UtcNow
            };
            
            if (doc.RootElement.TryGetProperty("result", out var result))
            {
                if (result.TryGetProperty("b", out var bids))
                {
                    foreach (var bid in bids.EnumerateArray())
                    {
                        snapshot.Bids.Add(new OrderBookLevel
                        {
                            Price = decimal.Parse(bid[0].GetString()),
                            Volume = decimal.Parse(bid[1].GetString())
                        });
                    }
                }
                
                if (result.TryGetProperty("a", out var asks))
                {
                    foreach (var ask in asks.EnumerateArray())
                    {
                        snapshot.Asks.Add(new OrderBookLevel
                        {
                            Price = decimal.Parse(ask[0].GetString()),
                            Volume = decimal.Parse(ask[1].GetString())
                        });
                    }
                }
            }
            
            return snapshot;
        }

        private List<Trade> ParseRecentTrades(string json)
        {
            var trades = new List<Trade>();
            using var doc = JsonDocument.Parse(json);
            
            if (doc.RootElement.TryGetProperty("result", out var result) &&
                result.TryGetProperty("list", out var list))
            {
                foreach (var trade in list.EnumerateArray())
                {
                    trades.Add(new Trade
                    {
                        Price = trade.GetProperty("price").GetDecimal(),
                        Volume = trade.GetProperty("size").GetDecimal(),
                        Side = trade.GetProperty("side").GetString() == "Buy" 
                            ? TradeSide.Buy : TradeSide.Sell,
                        Timestamp = DateTimeOffset.FromUnixTimeMilliseconds(
                            trade.GetProperty("time").GetInt64()).UtcDateTime,
                        Exchange = ExchangeName
                    });
                }
            }
            
            return trades;
        }

        private async Task SendMessageAsync(string message)
        {
            if (_webSocket?.State == WebSocketState.Open)
            {
                var bytes = Encoding.UTF8.GetBytes(message);
                await _webSocket.SendAsync(new ArraySegment<byte>(bytes), 
                    WebSocketMessageType.Text, true, CancellationToken.None);
            }
        }

        private async Task PingLoop(CancellationToken cancellationToken)
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                try
                {
                    await SendMessageAsync("{\"op\":\"ping\"}");
                    await Task.Delay(20000, cancellationToken);
                }
                catch { }
            }
        }

        public void Dispose()
        {
            DisconnectAsync().Wait();
            _httpClient?.Dispose();
        }
    }
}

// Binance Exchange Implementation
namespace TradingSystem.Exchange.Binance
{
    using System.Net.WebSockets;
    using System.Text;
    using System.Text.Json;
    using TradingSystem.Core.Models;
    using TradingSystem.Exchange.Interfaces;

    public class BinanceClient : IExchangeClient, IDisposable
    {
        private ClientWebSocket _webSocket;
        private CancellationTokenSource _cancellationTokenSource;
        private readonly HttpClient _httpClient;
        private readonly string _wsBaseUrl = "wss://fstream.binance.com/ws/";
        private readonly string _restUrl = "https://fapi.binance.com";
        private Task _receiveTask;
        private readonly List<string> _streamNames = new();
        
        public string ExchangeName => "Binance";
        
        public event EventHandler<Trade> OnTradeReceived;
        public event EventHandler<OrderBookSnapshot> OnOrderBookUpdate;
        public event EventHandler<decimal> OnOpenInterestUpdate;

        public BinanceClient()
        {
            _httpClient = new HttpClient();
            _httpClient.BaseAddress = new Uri(_restUrl);
        }

        public async Task<bool> ConnectAsync()
        {
            try
            {
                _webSocket = new ClientWebSocket();
                _cancellationTokenSource = new CancellationTokenSource();
                
                // Connect with empty stream initially
                await _webSocket.ConnectAsync(new Uri(_wsBaseUrl), _cancellationTokenSource.Token);
                
                // Start receive loop
                _receiveTask = Task.Run(() => ReceiveLoop(_cancellationTokenSource.Token));
                
                return _webSocket.State == WebSocketState.Open;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Binance connection error: {ex.Message}");
                return false;
            }
        }

        public async Task DisconnectAsync()
        {
            if (_webSocket?.State == WebSocketState.Open)
            {
                await _webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, 
                    "Closing connection", CancellationToken.None);
            }
            
            _cancellationTokenSource?.Cancel();
            _webSocket?.Dispose();
            _cancellationTokenSource?.Dispose();
        }

        public async Task SubscribeToTradesAsync(string symbol)
        {
            _streamNames.Add($"{symbol.ToLower()}@aggTrade");
            await ReconnectWithStreams();
        }

        public async Task SubscribeToOrderBookAsync(string symbol)
        {
            _streamNames.Add($"{symbol.ToLower()}@depth@100ms");
            await ReconnectWithStreams();
        }

        public async Task SubscribeToOpenInterestAsync(string symbol)
        {
            // Start periodic REST API calls for Open Interest
            _ = Task.Run(async () =>
            {
                while (!_cancellationTokenSource.Token.IsCancellationRequested)
                {
                    try
                    {
                        var openInterest = await GetOpenInterestAsync(symbol);
                        OnOpenInterestUpdate?.Invoke(this, openInterest);
                        await Task.Delay(5000, _cancellationTokenSource.Token);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"OI update error: {ex.Message}");
                    }
                }
            });
        }

        private async Task ReconnectWithStreams()
        {
            if (_streamNames.Count == 0) return;
            
            // Close existing connection
            if (_webSocket?.State == WebSocketState.Open)
            {
                await _webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, 
                    "Reconnecting", CancellationToken.None);
            }
            
            // Connect with combined streams
            _webSocket = new ClientWebSocket();
            var streamUrl = _wsBaseUrl + string.Join("/", _streamNames);
            await _webSocket.ConnectAsync(new Uri(streamUrl), _cancellationTokenSource.Token);
        }

        public async Task<OrderBookSnapshot> GetOrderBookAsync(string symbol, int depth = 100)
        {
            var response = await _httpClient.GetAsync(
                $"/fapi/v1/depth?symbol={symbol}&limit={depth}");
            
            if (response.IsSuccessStatusCode)
            {
                var json = await response.Content.ReadAsStringAsync();
                return ParseOrderBook(json);
            }
            
            return null;
        }

        public async Task<decimal> GetOpenInterestAsync(string symbol)
        {
            var response = await _httpClient.GetAsync(
                $"/fapi/v1/openInterest?symbol={symbol}");
            
            if (response.IsSuccessStatusCode)
            {
                var json = await response.Content.ReadAsStringAsync();
                using var doc = JsonDocument.Parse(json);
                
                if (doc.RootElement.TryGetProperty("openInterest", out var oi))
                {
                    return oi.GetDecimal();
                }
            }
            
            return 0;
        }

        public async Task<List<Trade>> GetRecentTradesAsync(string symbol, int limit = 1000)
        {
            var response = await _httpClient.GetAsync(
                $"/fapi/v1/aggTrades?symbol={symbol}&limit={limit}");
            
            if (response.IsSuccessStatusCode)
            {
                var json = await response.Content.ReadAsStringAsync();
                return ParseRecentTrades(json);
            }
            
            return new List<Trade>();
        }

        private async Task ReceiveLoop(CancellationToken cancellationToken)
        {
            var buffer = new ArraySegment<byte>(new byte[4096 * 4]);
            
            while (!cancellationToken.IsCancellationRequested && 
                   _webSocket.State == WebSocketState.Open)
            {
                try
                {
                    var result = await _webSocket.ReceiveAsync(buffer, cancellationToken);
                    
                    if (result.MessageType == WebSocketMessageType.Text)
                    {
                        var message = Encoding.UTF8.GetString(buffer.Array, 0, result.Count);
                        ProcessMessage(message);
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Receive error: {ex.Message}");
                }
            }
        }

        private void ProcessMessage(string message)
        {
            try
            {
                using var doc = JsonDocument.Parse(message);
                
                if (doc.RootElement.TryGetProperty("e", out var eventType))
                {
                    var eventStr = eventType.GetString();
                    
                    switch (eventStr)
                    {
                        case "aggTrade":
                            ProcessTradeMessage(doc.RootElement);
                            break;
                        case "depthUpdate":
                            ProcessOrderBookMessage(doc.RootElement);
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Process message error: {ex.Message}");
            }
        }

        private void ProcessTradeMessage(JsonElement root)
        {
            var trade = new Trade
            {
                Id = root.GetProperty("a").GetInt64().ToString(),
                Price = decimal.Parse(root.GetProperty("p").GetString()),
                Volume = decimal.Parse(root.GetProperty("q").GetString()),
                Side = root.GetProperty("m").GetBoolean() ? TradeSide.Sell : TradeSide.Buy,
                Timestamp = DateTimeOffset.FromUnixTimeMilliseconds(
                    root.GetProperty("T").GetInt64()).UtcDateTime,
                Exchange = ExchangeName
            };
            
            OnTradeReceived?.Invoke(this, trade);
        }

        private void ProcessOrderBookMessage(JsonElement root)
        {
            var snapshot = new OrderBookSnapshot
            {
                Bids = new List<OrderBookLevel>(),
                Asks = new List<OrderBookLevel>(),
                Timestamp = DateTime.UtcNow
            };
            
            if (root.TryGetProperty("b", out var bids))
            {
                foreach (var bid in bids.EnumerateArray())
                {
                    snapshot.Bids.Add(new OrderBookLevel
                    {
                        Price = decimal.Parse(bid[0].GetString()),
                        Volume = decimal.Parse(bid[1].GetString())
                    });
                }
            }
            
            if (root.TryGetProperty("a", out var asks))
            {
                foreach (var ask in asks.EnumerateArray())
                {
                    snapshot.Asks.Add(new OrderBookLevel
                    {
                        Price = decimal.Parse(ask[0].GetString()),
                        Volume = decimal.Parse(ask[1].GetString())
                    });
                }
            }
            
            OnOrderBookUpdate?.Invoke(this, snapshot);
        }

        private OrderBookSnapshot ParseOrderBook(string json)
        {
            using var doc = JsonDocument.Parse(json);
            var snapshot = new OrderBookSnapshot
            {
                Bids = new List<OrderBookLevel>(),
                Asks = new List<OrderBookLevel>(),
                Timestamp = DateTime.UtcNow
            };
            
            if (doc.RootElement.TryGetProperty("bids", out var bids))
            {
                foreach (var bid in bids.EnumerateArray())
                {
                    snapshot.Bids.Add(new OrderBookLevel
                    {
                        Price = decimal.Parse(bid[0].GetString()),
                        Volume = decimal.Parse(bid[1].GetString())
                    });
                }
            }
            
            if (doc.RootElement.TryGetProperty("asks", out var asks))
            {
                foreach (var ask in asks.EnumerateArray())
                {
                    snapshot.Asks.Add(new OrderBookLevel
                    {
                        Price = decimal.Parse(ask[0].GetString()),
                        Volume = decimal.Parse(ask[1].GetString())
                    });
                }
            }
            
            return snapshot;
        }

        private List<Trade> ParseRecentTrades(string json)
        {
            var trades = new List<Trade>();
            using var doc = JsonDocument.Parse(json);
            
            foreach (var trade in doc.RootElement.EnumerateArray())
            {
                trades.Add(new Trade
                {
                    Id = trade.GetProperty("a").GetInt64().ToString(),
                    Price = decimal.Parse(trade.GetProperty("p").GetString()),
                    Volume = decimal.Parse(trade.GetProperty("q").GetString()),
                    Side = trade.GetProperty("m").GetBoolean() ? TradeSide.Sell : TradeSide.Buy,
                    Timestamp = DateTimeOffset.FromUnixTimeMilliseconds(
                        trade.GetProperty("T").GetInt64()).UtcDateTime,
                    Exchange = ExchangeName
                });
            }
            
            return trades;
        }

        public void Dispose()
        {
            DisconnectAsync().Wait();
            _httpClient?.Dispose();
        }
    }
}

// Market Analyzer Implementation
namespace TradingSystem.Strategy.Implementation
{
    using TradingSystem.Core.Models;
    
    public class MarketAnalyzer : IMarketAnalyzer
    {
        private readonly List<TickBar> _historicalBars = new();
        private readonly object _lock = new();
        
        public decimal GetAverageVolume(int periods)
        {
            lock (_lock)
            {
                if (_historicalBars.Count < periods)
                    return _historicalBars.Count > 0 ? _historicalBars.Average(b => b.Volume) : 0;
                    
                return _historicalBars.TakeLast(periods).Average(b => b.Volume);
            }
        }
        
        public decimal GetATR()
        {
            lock (_lock)
            {
                if (_historicalBars.Count < 14)
                    return 0;
                    
                return _historicalBars.TakeLast(14).Average(b => b.PriceRange);
            }
        }
        
        public List<AccumulationZone> DetectAccumulationZones(List<TickBar> bars)
        {
            var zones = new List<AccumulationZone>();
            
            // Large bars analysis (10000-15000 ticks)
            var largeBars = bars.Where(b => b.TickSize >= 10000).ToList();
            zones.AddRange(DetectLargeBarZones(largeBars));
            
            // Medium bars analysis (1000-5000 ticks)
            var mediumBars = bars.Where(b => b.TickSize >= 1000 && b.TickSize < 5000).ToList();
            zones.AddRange(DetectMediumBarZones(mediumBars));
            
            // Merge overlapping zones
            return MergeOverlappingZones(zones);
        }
        
        private List<AccumulationZone> DetectLargeBarZones(List<TickBar> bars)
        {
            var zones = new List<AccumulationZone>();
            
            for (int i = 0; i < bars.Count - 5; i++)
            {
                var window = bars.Skip(i).Take(5).ToList();
                
                // Check for accumulation pattern
                if (window.All(b => b.FormationTime.TotalMinutes > 30) &&
                    window.Sum(b => b.Volume) > 2000 &&
                    window.Max(b => b.PriceRange) < GetATR() * 0.5m &&
                    Math.Abs(window.Sum(b => b.OpenPosBidChange - b.OpenPosAskChange)) > 500)
                {
                    zones.Add(new AccumulationZone
                    {
                        PriceLevel = window.Average(b => (b.HighPrice + b.LowPrice) / 2),
                        VolumeAccumulated = window.Sum(b => b.Volume),
                        Duration = window.Last().FormationStartTime - window.First().FormationStartTime,
                        OpenPosImbalance = window.Sum(b => b.OpenPosBidChange - b.OpenPosAskChange),
                        Type = ZoneType.Accumulation,
                        StartTime = window.First().FormationStartTime,
                        EndTime = window.Last().FormationStartTime.Add(window.Last().FormationTime),
                        StrengthScore = CalculateZoneStrength(window)
                    });
                }
            }
            
            return zones;
        }
        
        private List<AccumulationZone> DetectMediumBarZones(List<TickBar> bars)
        {
            var zones = new List<AccumulationZone>();
            
            for (int i = 0; i < bars.Count - 10; i++)
            {
                var window = bars.Skip(i).Take(10).ToList();
                
                // Check for support/resistance pattern
                var avgPrice = window.Average(b => (b.HighPrice + b.LowPrice) / 2);
                var priceDeviation = window.Average(b => Math.Abs((b.HighPrice + b.LowPrice) / 2 - avgPrice));
                
                if (priceDeviation < 2 && window.Sum(b => b.Volume) > 500)
                {
                    var deltaSum = window.Sum(b => b.Delta);
                    var zoneType = deltaSum > 0 ? ZoneType.Support : ZoneType.Resistance;
                    
                    zones.Add(new AccumulationZone
                    {
                        PriceLevel = avgPrice,
                        VolumeAccumulated = window.Sum(b => b.Volume),
                        Duration = window.Last().FormationStartTime - window.First().FormationStartTime,
                        OpenPosImbalance = window.Sum(b => b.OpenPosBidChange - b.OpenPosAskChange),
                        Type = zoneType,
                        StartTime = window.First().FormationStartTime,
                        TouchCount = CountTouches(avgPrice, bars),
                        StrengthScore = CalculateZoneStrength(window)
                    });
                }
            }
            
            return zones;
        }
        
        private List<AccumulationZone> MergeOverlappingZones(List<AccumulationZone> zones)
        {
            var merged = new List<AccumulationZone>();
            var sorted = zones.OrderBy(z => z.PriceLevel).ToList();
            
            foreach (var zone in sorted)
            {
                var existing = merged.FirstOrDefault(z => 
                    Math.Abs(z.PriceLevel - zone.PriceLevel) < 3);
                    
                if (existing != null)
                {
                    // Merge zones
                    existing.VolumeAccumulated += zone.VolumeAccumulated;
                    existing.OpenPosImbalance += zone.OpenPosImbalance;
                    existing.StrengthScore = Math.Max(existing.StrengthScore, zone.StrengthScore);
                    existing.TouchCount = Math.Max(existing.TouchCount, zone.TouchCount);
                }
                else
                {
                    merged.Add(zone);
                }
            }
            
            return merged;
        }
        
        private int CountTouches(decimal priceLevel, List<TickBar> bars)
        {
            return bars.Count(b => 
                (b.LowPrice <= priceLevel && b.HighPrice >= priceLevel) ||
                Math.Abs(b.LowPrice - priceLevel) < 1 ||
                Math.Abs(b.HighPrice - priceLevel) < 1);
        }
        
        private decimal CalculateZoneStrength(List<TickBar> window)
        {
            var score = 0m;
            
            // Volume factor
            var avgVolume = GetAverageVolume(20);
            if (avgVolume > 0)
                score += (window.Average(b => b.Volume) / avgVolume) * 30;
            
            // Time factor
            var avgFormationTime = window.Average(b => b.FormationTime.TotalMinutes);
            if (avgFormationTime > 30) score += 20;
            
            // Price stability factor
            var priceRange = window.Max(b => b.HighPrice) - window.Min(b => b.LowPrice);
            if (priceRange < 2) score += 25;
            
            // Open interest factor
            var oiImbalance = Math.Abs(window.Sum(b => b.OpenPosBidChange - b.OpenPosAskChange));
            if (oiImbalance > 500) score += 25;
            
            return Math.Min(score, 100);
        }
        
        public bool IsBreakout(TickBar currentBar, AccumulationZone zone)
        {
            if (currentBar == null || zone == null) return false;
            
            // Check if price breaks through zone
            var priceBreakout = (currentBar.ClosePrice > zone.PriceLevel + 2) ||
                               (currentBar.ClosePrice < zone.PriceLevel - 2);
            
            // Check volume expansion
            var volumeExpansion = currentBar.Volume > GetAverageVolume(10) * 3;
            
            // Check formation speed
            var fastFormation = currentBar.FormationTime.TotalMinutes < 3;
            
            return priceBreakout && volumeExpansion && fastFormation;
        }
        
        public BreakoutInfo AnalyzeBreakout(List<TickBar> bars, AccumulationZone zone)
        {
            var recentBars = bars.TakeLast(5).ToList();
            var breakoutInfo = new BreakoutInfo();
            
            if (!recentBars.Any()) return breakoutInfo;
            
            var triggerBar = recentBars.Last();
            var avgVolume = GetAverageVolume(20);
            
            // Determine breakout type
            if (triggerBar.ClosePrice > zone.PriceLevel)
            {
                breakoutInfo.Type = BreakoutType.Bullish;
                breakoutInfo.PriceExtension = triggerBar.ClosePrice - zone.PriceLevel;
            }
            else
            {
                breakoutInfo.Type = BreakoutType.Bearish;
                breakoutInfo.PriceExtension = zone.PriceLevel - triggerBar.ClosePrice;
            }
            
            // Calculate volume expansion
            if (avgVolume > 0)
                breakoutInfo.VolumeExpansion = triggerBar.Volume / avgVolume;
            
            // Determine grade
            if (zone.VolumeAccumulated > 1000 && breakoutInfo.VolumeExpansion > 5 &&
                Math.Abs(triggerBar.DeltaPercentage) > 0.85m)
            {
                breakoutInfo.Grade = BreakoutGrade.Explosive;
                breakoutInfo.Strength = 0.9m;
            }
            else if (zone.VolumeAccumulated > 500 && breakoutInfo.VolumeExpansion > 3 &&
                    Math.Abs(triggerBar.DeltaPercentage) > 0.7m)
            {
                breakoutInfo.Grade = BreakoutGrade.Strong;
                breakoutInfo.Strength = 0.7m;
            }
            else
            {
                breakoutInfo.Grade = BreakoutGrade.Moderate;
                breakoutInfo.Strength = 0.5m;
            }
            
            // Check for confirmation
            breakoutInfo.IsConfirmed = recentBars.TakeLast(3).All(b =>
                (breakoutInfo.Type == BreakoutType.Bullish ? 
                    b.ClosePrice > zone.PriceLevel : 
                    b.ClosePrice < zone.PriceLevel));
            
            // Check for false breakout
            if (recentBars.Count >= 3)
            {
                var returnedToZone = breakoutInfo.Type == BreakoutType.Bullish ?
                    recentBars.Any(b => b.ClosePrice < zone.PriceLevel) :
                    recentBars.Any(b => b.ClosePrice > zone.PriceLevel);
                    
                if (returnedToZone)
                {
                    breakoutInfo.Type = BreakoutType.False;
                    breakoutInfo.IsConfirmed = false;
                }
            }
            
            return breakoutInfo;
        }
        
        public void UpdateHistoricalBars(TickBar bar)
        {
            lock (_lock)
            {
                _historicalBars.Add(bar);
                
                // Keep only last 1000 bars
                if (_historicalBars.Count > 1000)
                    _historicalBars.RemoveAt(0);
            }
        }
    }
    
    // Notification Service Implementation
    public class NotificationService : INotificationService
    {
        private readonly Queue<ImbalanceSignal> _validationQueue = new();
        private readonly SemaphoreSlim _queueSemaphore = new(1, 1);
        
        public async Task SendAlertAsync(ImbalanceSignal signal)
        {
            // Implement your notification logic here
            // Could be: Email, Telegram, Discord, etc.
            
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine($"🚨 CRITICAL ALERT: {signal.Type}");
            Console.WriteLine($"   Description: {signal.Description}");
            Console.WriteLine($"   Confidence: {signal.ConfidenceLevel:P}");
            Console.WriteLine($"   Timestamp: {signal.Timestamp:yyyy-MM-dd HH:mm:ss}");
            
            foreach (var metric in signal.Metrics)
            {
                Console.WriteLine($"   {metric.Key}: {metric.Value:F2}");
            }
            
            Console.ResetColor();
            
            await Task.CompletedTask;
        }
        
        public async Task QueueForValidationAsync(ImbalanceSignal signal)
        {
            await _queueSemaphore.WaitAsync();
            try
            {
                _validationQueue.Enqueue(signal);
                
                // Process validation queue if it gets too large
                if (_validationQueue.Count > 10)
                {
                    await ProcessValidationQueue();
                }
            }
            finally
            {
                _queueSemaphore.Release();
            }
        }
        
        private async Task ProcessValidationQueue()
        {
            var signalsToValidate = new List<ImbalanceSignal>();
            
            while (_validationQueue.Count > 0)
            {
                signalsToValidate.Add(_validationQueue.Dequeue());
            }
            
            // Group similar signals
            var groupedSignals = signalsToValidate
                .GroupBy(s => s.Type)
                .Where(g => g.Count() >= 2); // Need at least 2 similar signals
            
            foreach (var group in groupedSignals)
            {
                var strongestSignal = group.OrderByDescending(s => s.ConfidenceLevel).First();
                
                Console.ForegroundColor = ConsoleColor.Yellow;
                Console.WriteLine($"⚡ VALIDATED SIGNAL: {strongestSignal.Type}");
                Console.WriteLine($"   Occurrences: {group.Count()}");
                Console.WriteLine($"   Max Confidence: {strongestSignal.ConfidenceLevel:P}");
                Console.ResetColor();
                
                await Task.CompletedTask;
            }
        }
    }
}

// Program Entry Point
namespace TradingSystem
{
    using TradingSystem.Core;
    using TradingSystem.Exchange.Bybit;
    using TradingSystem.Exchange.Binance;
    using TradingSystem.Exchange.Interfaces;
    using TradingSystem.Processing;
    using TradingSystem.Strategy;
    using TradingSystem.Strategy.Implementation;
    
    class Program
    {
        static async Task Main(string[] args)
        {
            Console.WriteLine("Starting Trading System - Market Imbalance Detector");
            Console.WriteLine("==================================================");
            
            // Initialize components
            var exchanges = new List<IExchangeClient>
            {
                new BybitClient(),
                new BinanceClient()
            };
            
            var tickBarBuilder = new TickBarBuilder();
            var dataAggregator = new MarketDataAggregator(tickBarBuilder);
            var marketAnalyzer = new MarketAnalyzer();
            var imbalanceConfig = new ImbalanceConfig();
            var imbalanceDetector = new ImbalanceDetector(imbalanceConfig, marketAnalyzer);
            var notificationService = new NotificationService();
            
            // Subscribe to bar completed events
            tickBarBuilder.OnBarCompleted += (sender, bar) =>
            {
                marketAnalyzer.UpdateHistoricalBars(bar);
                Console.WriteLine($"[{bar.TickSize} ticks] Bar completed: " +
                    $"Vol={bar.Volume:F2}, Delta={bar.DeltaPercentage:P}, " +
                    $"Time={bar.FormationTime.TotalSeconds:F1}s");
            };
            
            // Create orchestrator
            var orchestrator = new TradingSystemOrchestrator(
                exchanges,
                dataAggregator,
                imbalanceDetector,
                marketAnalyzer,
                notificationService
            );
            
            // Start system
            await orchestrator.StartAsync();
            
            Console.WriteLine("\nSystem is running. Press 'Q' to quit.");
            
            // Wait for exit
            while (true)
            {
                var key = Console.ReadKey(true);
                if (key.Key == ConsoleKey.Q)
                    break;
            }
            
            // Stop system
            await orchestrator.StopAsync();
            
            Console.WriteLine("\nSystem stopped.");
        }
    }
}